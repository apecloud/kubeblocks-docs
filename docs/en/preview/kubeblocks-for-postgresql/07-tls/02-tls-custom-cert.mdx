---
title: Deploy a PostgreSQL Cluster with User-Provided TLS on KubeBlocks
description: Learn how to deploy a PostgreSQL cluster on KubeBlocks with user-provided TLS certificates for secure communication. This guide covers generating certificates, deploying the cluster, and verifying secure connections.
keywords: [KubeBlocks, PostgreSQL, Kubernetes, TLS, Secure Communication, User-Provided Certificates]
sidebar_position: 2
sidebar_label: PostgreSQL Cluster with User-Provided TLS
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Deploy a PostgreSQL Cluster with User-Provided TLS on KubeBlocks

This guide explains how to deploy a PostgreSQL cluster with **user-provided TLS certificates** using KubeBlocks. By supplying your own certificates, you have full control over the security configuration for encrypted communication between the PostgreSQL client and server. This guide covers generating certificates, deploying the cluster, and verifying the secure connection.

## Prerequisites

Before proceeding, ensure the following:
- Environment Setup:
    - A Kubernetes cluster is up and running.
    - The kubectl CLI tool is configured to communicate with your cluster.
    - KubeBlocks CLI and KubeBlocks Operator are installed. Follow the installation instructions here.
- Namespace Preparation: To keep resources isolated, create a dedicated namespace for this tutorial:

```bash
$ kubectl create ns demo
namespace/demo created
```

## Generating Certificates

To enable TLS encryption, you will need to provide a Certificate Authority (CA), a server certificate, and a private key. Follow these steps to generate these using OpenSSL:

1. Generate the Root Certificate (CA)
```bash
# Create the CA private key (password optional)
openssl genrsa -aes256 -out ca-key.pem 4096

# Generate a self-signed root certificate (valid for 10 years)
openssl req -x509 -new -nodes -key ca-key.pem -sha256 -days 3650 -out ca.pem
# Enter the required information (e.g., Common Name can be "PostgreSQL Root CA")
```

2. Generate the Server Certificate & Key
```bash
# Generate the server private key
openssl genrsa -out server-key.pem 4096

# Create a Certificate Signing Request (CSR)
openssl req -new -key server-key.pem -out server-req.pem
# Enter server identification details, such as:
# Common Name (CN) = Server domain name or IP (must match the PostgreSQL server address!)

# Sign the server certificate with the CA (valid for 10 years)
openssl x509 -req -in server-req.pem -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out server-cert.pem -days 3650 -sha256
```

:::import

Common Name (CN) = Server domain name or IP (must match the PostgreSQL server address!)
for instance, use service name `pg-cluster-postgresql-postgresql` in this example.

:::

3. Verify the Certificates
Verify that the server certificate is valid and signed by the CA:
```bash
# Verify the server certificate
openssl verify -CAfile ca.pem server-cert.pem
```
Example Output:
```bash
server-cert.pem: OK
```

## Create Kubernetes Secrets
Store the generated certificates and keys in a Kubernetes Secret to make them accessible to your PostgreSQL cluster:
```bash
kubectl create secret generic postgresql-tls-secret \
  --namespace=demo \
  --from-file=ca.crt=ca.pem \
  --from-file=tls.crt=server-cert.pem \
  --from-file=tls.key=server-key.pem \
  --type=kubernetes.io/tls
```
This secret contains the CA, server certificate, and private key required to enable mTLS on the PostgreSQL cluster.

## Deploying the PostgreSQL Replication Cluster

KubeBlocks uses a declarative approach for managing PostgreSQL clusters. Below is an example configuration for deploying a PostgreSQL cluster with 2 nodes (1 primary, 1 replicas) with user-provided TLS certificates:
```yaml
apiVersion: apps.kubeblocks.io/v1
kind: Cluster
metadata:
  name: pg-cluster
  namespace: demo
spec:
  terminationPolicy: Delete
  clusterDef: postgresql
  topology: replication
  componentSpecs:
    - name: postgresql
      serviceVersion: 16.4.0
      tls: true  # enable tls
      issuer:    # set issuer to UserProvided
        name: UserProvided
        secretRef:
          name: postgresql-tls-secret
          namespace: demo
          ca: ca.crt
          cert: tls.crt
          key: tls.key
      labels:
        apps.kubeblocks.postgres.patroni/scope: pg-cluster-postgresql
      disableExporter: true
      replicas: 2
      resources:
        limits:
          cpu: "0.5"
          memory: "0.5Gi"
        requests:
          cpu: "0.5"
          memory: "0.5Gi"
      volumeClaimTemplates:
        - name: data
          spec:
            accessModes:
              - ReadWriteOnce
            resources:
              requests:
                storage: 20Gi
```

**Explanation of Key Fields**
- `tls: true`: Enables TLS encryption for secure communication.
- `issuer.name: UserProvided`: Specifies that user-provided certificates are being used.
- `issuer.secretRef`: Links the cluster to the Kubernetes Secret containing the certificates.

## Verifying the Deployment
Monitor the cluster status until it transitions to the Running state:
```bash
$ kubectl get cluster pg-cluster -n demo -w
```

Example Output::

```bash
NAME         CLUSTER-DEFINITION   TERMINATION-POLICY   STATUS     AGE
pg-cluster   postgresql           Delete               Creating   50s
pg-cluster   postgresql           Delete               Running    4m2s
```
Once the cluster status becomes Running, your PostgreSQL cluster is ready for use.

Verify SSL configuration on both replicas:

```sql
postgres=# show ssl;
 ssl
-----
 on
(1 row)

postgres=# show ssl_ca_file;
     ssl_ca_file
---------------------
 /etc/pki/tls/ca.pem
(1 row)

postgres=# show ssl_cert_file;
     ssl_cert_file
-----------------------
 /etc/pki/tls/cert.pem
(1 row)

postgres=# show ssl_key_file;
     ssl_key_file
----------------------
 /etc/pki/tls/key.pem
(1 row)
```

## Connect to PostgreSQL Cluster

### Step 1: Retrieve the Root Credentials

KubeBlocks creates a Secret named `pg-cluster-postgresql-account-postgres` containing PostgreSQL postgres credentials.

Retrieve credentials:

```bash
NAME=`kubectl get secret -n demo pg-cluster-postgresql-account-postgres -o jsonpath='{.data.username}' | base64 --decode`
PASSWD=`kubectl get secret -n demo pg-cluster-postgresql-account-postgres -o jsonpath='{.data.password}' | base64 --decode`
```

### Step 2: Connect to PostgreSQL Securely Using TLS
Use the PostgreSQL client to connect securely with TLS enabled. The 'sslmode' option enforces the use of TLS for encryption.


<Tabs>
<TabItem value="require" label="sslmode-require" default>

Forward PostgreSQL port to localhost:

```bash
$ kubectl port-forward svc/pg-cluster-postgresql-postgresql 5432:5432 -n demo
Forwarding from 127.0.0.1:5432 -> 5432
Forwarding from [::1]:5432 -> 5432
```

Connect with `sslmode=require`

```bash
psql "host=127.0.0.1 dbname=postgres user=${NAME} password=${PASSWD} sslmode=require"
```

Sample Output:
```bash
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, compression: off, ALPN: none)
Type "help" for help.

postgres=#
```

It shows `SSL connection` in command line.

</TabItem>

<TabItem value="require" label="sslmode=verify-full">

```
kubectl exec -it -n demo pg-cluster-postgresql-0 -c postgresql -- env PGUSER=${NAME} PGPASSWORD=${PASSWD} psql 'host=pg-cluster-postgresql-postgresql sslmode=require sslrootcert=/etc/pki/tls/ca.pem'
```

Sample Output:
```bash
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, compression: off, ALPN: none)
Type "help" for help.

postgres=#
```

It shows `SSL connection` in command line.

</TabItem>
</Tabs>

## Summary
In this guide, you learned how to:
- Generate a self-signed CA and server certificates using OpenSSL.
- Store the certificates in a Kubernetes Secret.
- Deploy a PostgreSQL cluster with TLS encryption using KubeBlocks.
- Connect to the PostgreSQL cluster securely using TLS and verify the connection.

Using TLS ensures secure communication between the PostgreSQL client and server, protecting sensitive data in transit. By following these steps, you can easily set up and manage a secure PostgreSQL cluster on Kubernetes using KubeBlocks.