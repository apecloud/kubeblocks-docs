---
title: Expanding Volume in a PostgreSQL Cluster
description: Learn how to expand Persistent Volume Claims (PVCs) in a PostgreSQL cluster managed by KubeBlocks without downtime.
keywords: [KubeBlocks, PostgreSQL, Volume Expansion, Kubernetes, PVC]
sidebar_position: 4
sidebar_label: Volume Expansion
---


import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


# Expanding Volume in a PostgreSQL Cluster

This guide explains how to expand Persistent Volume Claims (PVCs) in a PostgreSQL cluster managed by **KubeBlocks**. Volume expansion enables dynamic storage capacity increases, allowing your database to scale seamlessly as data grows. When supported by the underlying storage class, this operation can be performed without downtime.

Volume expansion allows you to increase the size of a Persistent Volume Claim (PVC) after it has been created. This feature was introduced in Kubernetes v1.11 and became generally available (GA) in Kubernetes v1.24.

Key considerations:
- Supported Storage Class: The storage class used for the PVC must support volume expansion.
- No Downtime: In most cases, volume expansion can be performed without downtime.
- Incremental Expansion: The new size must be larger than the current size.

:::note
1. Ensure the storage class supports volume expansion (check ALLOWVOLUMEEXPANSION).
2. The new size must be larger than the current size.
3. Volume expansion may require additional configurations depending on the storage provider.
:::

## Prerequisites

Before proceeding, ensure the following:
- Environment Setup:
    - A Kubernetes cluster is up and running.
    - The kubectl CLI tool is configured to communicate with your cluster.
    - KubeBlocks CLI and KubeBlocks Operator are installed.
- Namespace Preparation: To keep resources isolated, create a dedicated namespace for this tutorial:

```bash
$ kubectl create ns demo
namespace/demo created
```

### Check the Storage Class for Volume Expansion Support

List all available storage classes and verify if volume expansion is supported by checking the `ALLOWVOLUMEEXPANSION` field:
```bash
kubectl get storageclass
```

Example Outputs:
```bash
NAME                PROVISIONER             RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE
gp2                 kubernetes.io/aws-ebs   Delete          WaitForFirstConsumer   false                  4d10h
kb-default-sc       ebs.csi.aws.com         Delete          WaitForFirstConsumer   true                   3d7h
sc-s3-repo-2qsxfh   ru.yandex.s3.csi        Retain          Immediate              false                  3d7h
```
Ensure the storage class you are using has `ALLOWVOLUMEEXPANSION` set to true. If it is false, the storage class does not support volume expansion.


## Deploy a PostgreSQL Replication Cluster with StorageClass specified

KubeBlocks uses a declarative approach to manage PostgreSQL clusters. Below is an example configuration for deploying a PostgreSQL cluster with 2 replicas (1 primary, 1 secondary).

Apply the following YAML configuration to deploy the cluster:

```yaml
apiVersion: apps.kubeblocks.io/v1
kind: Cluster
metadata:
  name: pg-cluster
  namespace: demo
spec:
  terminationPolicy: Delete
  clusterDef: postgresql
  topology: replication
  componentSpecs:
    - name: postgresql
      serviceVersion: 16.4.0
      labels:
        apps.kubeblocks.postgres.patroni/scope: pg-cluster-postgresql
      disableExporter: true
      replicas: 2
      resources:
        limits:
          cpu: "0.5"
          memory: "0.5Gi"
        requests:
          cpu: "0.5"
          memory: "0.5Gi"
      volumeClaimTemplates:
        - name: data
          spec:
            storageClassName: <STORAGE_CLASS_NAME> # specify storage class name
            accessModes:
              - ReadWriteOnce
            resources:
              requests:
                storage: 20Gi
```
**Explanation of Key Fields**
- `storageClassName`: specify StorageClass name that supports volume expansion. If not set, the StorageClass annotated `default` will be used.



## Verifying the Deployment
Monitor the cluster status until it transitions to the Running state:
```bash
$ kubectl get cluster pg-cluster -n demo -w
```

Example Output:

```bash
NAME         CLUSTER-DEFINITION   TERMINATION-POLICY   STATUS     AGE
pg-cluster   postgresql           Delete               Creating   50s
pg-cluster   postgresql           Delete               Running    4m2s
```
Once the cluster status becomes Running, your PostgreSQL cluster is ready for use.

:::tip
If you are creating the cluster for the very first time, it may take some time to pull images before running.

:::

## Expand volume

You can expand the volume in one of two ways:
<Tabs>

  <TabItem value="opsRequest" label="Use the OpsRequest API" default>

  ### Option 1: Using VolumeExpansion OpsRequest

  Apply the following YAML to increase the volume size for the postgresql component:

  ```yaml
  apiVersion: operations.kubeblocks.io/v1alpha1
  kind: OpsRequest
  metadata:
    name: pg-cluster-expand-volume-ops
    namespace: demo
  spec:
    clusterName: pg-cluster
    type: VolumeExpansion
    volumeExpansion:
    - componentName: postgresql
      volumeClaimTemplates:
      - name: data
        storage: 30Gi
  ```

  Monitor the expansion progress with:

  ```bash
  kubectl describe ops pg-cluster-expand-volume-ops -n demo
  ```

  Expected Result:
  ```bash
  Status:
    Phase:            Succeed
  ```
  Once completed, the PVC size will be updated.

  :::note
  If the storage class you use does not support volume expansion, this OpsRequest fails fast with information like:
  `storageClass: [STORAGE_CLASS_NAME] of volumeClaimTemplate: [VOLUME_NAME]] not support volume expansion in component [COMPONENT_NAME]`
  :::

  </TabItem>

  <TabItem value="ClusterAPI" label="Use the Cluster API">

  ### Option 2: Direct Cluster API Update

  Alternatively, you may update the `spec.componentSpecs.volumeClaimTemplates.spec.resources.requests.storage` field to the desired size.

  ```yaml
  apiVersion: apps.kubeblocks.io/v1
  kind: Cluster
  metadata:
    name: pg-cluster
    namespace: demo
  spec:
    terminationPolicy: Delete
    clusterDef: postgresql
    topology: replication
    componentSpecs:
      - name: postgresql
        serviceVersion: 16.4.0
        labels:
          apps.kubeblocks.postgres.patroni/scope: pg-cluster-postgresql
        disableExporter: true
        replicas: 2
        resources:
          limits:
            cpu: "0.5"
            memory: "0.5Gi"
          requests:
            cpu: "0.5"
            memory: "0.5Gi"
        volumeClaimTemplates:
          - name: data
            spec:
              storageClassName: <STORAGE_CLASS_NAME>
              accessModes:
                - ReadWriteOnce
              resources:
                requests:
                  storage: 30Gi  # specify new size, and make sure it is larger than current size
  ```
  KubeBlocks will automatically update the PVC size based on the new specifications.
  </TabItem>
</Tabs>

## Verification

Verify the updated cluster configuration:
```bash
$ kbcli cluster describe pg-cluster -n demo
```
Example Output:
```bash
Resources Allocation:
COMPONENT   INSTANCE-TEMPLATE   CPU(REQUEST/LIMIT)   MEMORY(REQUEST/LIMIT)   STORAGE-SIZE   STORAGE-CLASS
postgresql                           500m / 500m          512Mi / 512Mi      data:30Gi      <STORAGE_CLASS_NAME>
```
The volume size for the data PVC has been updated to the specified value (e.g., 30Gi in this case).

Confirm PVC resizing completion:
```bash
kubectl get pvc -l app.kubernetes.io/instance=pg-cluster -n demo
```
Example Output:
```bash
NAME                                     STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS          AGE
pg-cluster-postgresql-data-0             Bound    pvc-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx   30Gi       RWO            <STORAGE_CLASS_NAME>  33m
pg-cluster-postgresql-data-1             Bound    pvc-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx   30Gi       RWO            <STORAGE_CLASS_NAME>  33m
```

## Summary

In this guide you learned how to:
1. Verify storage class compatibility for volume expansion.
2. Perform volume expansion using either:
   - OpsRequest for dynamic updates.
   - Cluster API for manual updates.
3. Verify the updated PVC size and ensure the resize operation is complete.

With volume expansion, you can efficiently scale your PostgreSQL cluster's storage capacity without service interruptions, ensuring your database can grow alongside your application needs.


