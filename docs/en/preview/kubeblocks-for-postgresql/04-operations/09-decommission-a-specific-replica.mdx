---
title: Decommission a Specific Pod in KubeBlocks-Managed PostgreSQL Clusters
description: Learn how to decommission (take offline) a specific Pod in a PostgreSQL cluster managed by KubeBlocks.
keywords: [KubeBlocks, PostgreSQL, Decommission Pod, Horizontal Scaling, Kubernetes]
sidebar_position: 9
sidebar_label: Decommission PostgreSQL Replica
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';



# Decommission a Specific Pod in a KubeBlocks-Managed PostgreSQL Clusters

This guide explains how to decommission (take offline) a specific Pod in a PostgreSQL cluster managed by KubeBlocks. Decommissioning a Pod allows precise control over cluster resources without disrupting the cluster's overall functionality. This is particularly useful for workload rebalancing, node maintenance, or addressing specific failures.

## Why Decommission Pods with KubeBlocks?

In traditional StatefulSet-based deployments, Kubernetes lacks the ability to decommission specific Pods. StatefulSets ensure the order and identity of Pods, and scaling down always removes the Pod with the highest ordinal number (e.g., scaling down from 3 replicas removes Pod `-2` first). This limitation prevents precise control over which Pod to take offline, which can complicate maintenance, workload distribution, or failure handling.

KubeBlocks overcomes this limitation by enabling administrators to decommission specific Pods directly. This fine-grained control ensures high availability and allows better resource management without disrupting the entire cluster.

## Prerequisites

Before proceeding, ensure the following:
- Environment Setup:
    - A Kubernetes cluster is up and running.
    - The kubectl CLI tool is configured to communicate with your cluster.
    - KubeBlocks CLI and KubeBlocks Operator are installed. Follow the installation instructions here.
- Namespace Preparation: To keep resources isolated, create a dedicated namespace for this tutorial:

```bash
$ kubectl create ns demo
namespace/demo created
```

## Deploy a PostgreSQL Cluster

Deploy a 2-node semi-sync PostgreSQL cluster (1 primary, 1 secondary):

```yaml
apiVersion: apps.kubeblocks.io/v1
kind: Cluster
metadata:
  name: pg-cluster
  namespace: demo
spec:
  terminationPolicy: Delete
  clusterDef: postgresql
  topology: replication
  componentSpecs:
    - name: postgresql
      serviceVersion: 16.4.0
      labels:
        apps.kubeblocks.postgres.patroni/scope: pg-cluster-postgresql
      disableExporter: true
      replicas: 2
      resources:
        limits:
          cpu: "0.5"
          memory: "0.5Gi"
        requests:
          cpu: "0.5"
          memory: "0.5Gi"
      volumeClaimTemplates:
        - name: data
          spec:
            accessModes:
              - ReadWriteOnce
            resources:
              requests:
                storage: 20Gi
```

## Verifying the Deployment

Monitor the cluster status until it transitions to the Running state:
```bash
$ kubectl get cluster pg-cluster -n demo -w
```

Example Output::

```bash
NAME         CLUSTER-DEFINITION   TERMINATION-POLICY   STATUS     AGE
pg-cluster   postgresql           Delete               Creating   50s
pg-cluster   postgresql           Delete               Running    4m2s
```
Once the cluster status becomes Running, your PostgreSQL cluster is ready for use.

:::tip
If you are creating the cluster for the very first time, it may take some time to pull images before running.

:::

## Decommission a Specific Pod

**Expected Workflow**:

1. Selected replica (specified in `onlineInstancesToOffline`) is removed
2. Pod is terminated gracefully
3. Cluster status changes from `Updating` to `Running`

To decommission a specific Pod (e.g., 'pg-cluster-postgresql-1'), you can use one of the following methods:

<Tabs>

  <TabItem value="opsRequest" label="Use the OpsRequest API" default>

  ### Option 1: Using OpsRequest
  Create an OpsRequest to mark the Pod as offline:

  ```yaml
  apiVersion: operations.kubeblocks.io/v1alpha1
  kind: OpsRequest
  metadata:
    name: pg-cluster-decommission-ops
    namespace: demo
  spec:
    clusterName: pg-cluster
    type: HorizontalScaling
    horizontalScaling:
    - componentName: postgresql
      scaleIn:
        onlineInstancesToOffline:
          - 'pg-cluster-postgresql-1'  # Specifies the instance names that need to be taken offline
  ```

  #### Monitor the Decommissioning Process
  Check the progress of the decommissioning operation:

  ```bash
  kubectl describe ops pg-cluster-decommission-ops -n demo
  ```
  Expected Output:

  ```bash
  Status:
    Phase:              Succeed
    Progress:           1/1
    ...
  ```

  </TabItem>

  <TabItem value="ClusterAPI" label="Use the Cluster API">

  ### Option 2: Using Cluster API
  Alternatively, update the Cluster resource directly to decommission the Pod:

  ```yaml
  apiVersion: apps.kubeblocks.io/v1
  kind: Cluster
  metadata:
    name: pg-cluster
    namespace: demo
  spec:
    terminationPolicy: Delete
    clusterDef: postgresql
    topology: replication
    componentSpecs:
      - name: postgresql
        serviceVersion: 16.4.0
        labels:
          apps.kubeblocks.postgres.patroni/scope: pg-cluster-postgresql
        disableExporter: true
        replicas: 1
        offlineInstances:
          - pg-cluster-postgresql-1   # <----- Specify Pod to be decommissioned
        resources:
          limits:
            cpu: '0.5'
            memory: 0.5Gi
          requests:
            cpu: '0.5'
            memory: 0.5Gi
        volumeClaimTemplates:
          - name: data
            spec:
              storageClassName: ""
              accessModes:
                - ReadWriteOnce
              resources:
                requests:
                  storage: 20Gi
  ```
  </TabItem>

</Tabs>

### Verify the Decommissioning

After applying the updated configuration, verify the remaining Pods in the cluster:
```bash
$ kubectl get pods -n demo -l app.kubernetes.io/instance=pg-cluster
```

Expected Output:
```bash
NAME                      READY   STATUS    RESTARTS   AGE
pg-cluster-postgresql-0   4/4     Running   0          6m12s
```

## Summary
In this guide, you learned:
- The limitations of traditional StatefulSet-based scaling in Kubernetes.
- How KubeBlocks enables precise decommissioning of specific Pods.
- Two methods to decommission a Pod: using OpsRequest or directly updating the Cluster API.
By leveraging KubeBlocks, you can manage PostgreSQL clusters with fine-grained control, ensuring high availability and flexibility for maintenance and workload distribution.