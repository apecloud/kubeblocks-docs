---
title: Managing PostgreSQL Cluster Lifecycle (Stop, Start, and Restart)
description: Learn how to manage the lifecycle of a PostgreSQL cluster in KubeBlocks, including stopping, starting, and restarting clusters to optimize resource usage and maintain flexibility.
keywords: [KubeBlocks, PostgreSQL, Cluster Management, Stop, Start, Restart]
sidebar_position: 1
sidebar_label: Lifecycle Management
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


# Managing PostgreSQL Cluster Lifecycle

This guide demonstrates how to manage the lifecycle of a PostgreSQL cluster in **KubeBlocks**, including stopping, starting, and restarting the cluster. Proper lifecycle management helps optimize resource usage, reduce operational costs, and ensure flexibility in your Kubernetes environment.


## Prerequisites

Before proceeding, ensure the following:
- Environment Setup:
    - A Kubernetes cluster is up and running.
    - The kubectl CLI tool is configured to communicate with your cluster.
    - KubeBlocks CLI and KubeBlocks Operator are installed.
- Namespace Preparation: To keep resources isolated, create a dedicated namespace for this tutorial:

```bash
$ kubectl create ns demo
namespace/demo created
```

## Deploy a PostgreSQL Replication Cluster

KubeBlocks uses a declarative approach for managing PostgreSQL clusters. Below is an example configuration for deploying a PostgreSQL cluster with 2 replicas (1 primary, 1 replicas).

Apply the following YAML configuration to deploy the cluster:

```yaml
apiVersion: apps.kubeblocks.io/v1
kind: Cluster
metadata:
  name: pg-cluster
  namespace: demo
spec:
  terminationPolicy: Delete
  clusterDef: postgresql
  topology: replication
  componentSpecs:
    - name: postgresql
      serviceVersion: 16.4.0
      labels:
        apps.kubeblocks.postgres.patroni/scope: pg-cluster-postgresql
      disableExporter: true
      replicas: 2
      resources:
        limits:
          cpu: "0.5"
          memory: "0.5Gi"
        requests:
          cpu: "0.5"
          memory: "0.5Gi"
      volumeClaimTemplates:
        - name: data
          spec:
            accessModes:
              - ReadWriteOnce
            resources:
              requests:
                storage: 20Gi
```

## Verifying the Deployment
Monitor the cluster status until it transitions to the Running state:
```bash
$ kubectl get cluster pg-cluster -n demo -w
```

Example Output::

```bash
NAME         CLUSTER-DEFINITION   TERMINATION-POLICY   STATUS     AGE
pg-cluster   postgresql           Delete               Creating   50s
pg-cluster   postgresql           Delete               Running    4m2s
```
Once the cluster status becomes Running, your PostgreSQL cluster is ready for use.

:::tip
If you are creating the cluster for the very first time, it may take some time to pull images before running.

:::

## Managing the Cluster Lifecycle

### Stop the Cluster

Stopping the cluster terminates all its running pods but retains the persistent storage. This is useful when you want to temporarily suspend the cluster to save costs.

<Tabs>

  <TabItem value="opsRequest" label="OpsRequest API" default>

  #### Option 1: Using OpsRequest

  You can stop the cluster using an OpsRequest:

  ```yaml
  apiVersion: operations.kubeblocks.io/v1alpha1
  kind: OpsRequest
  metadata:
    name: pg-cluster-stop-ops
    namespace: demo
  spec:
    clusterName: pg-cluster
    type: Stop
  ```
  </TabItem>

  <TabItem value="ClusterAPI" label="Cluster API">

  #### Option 2: Using the Declarative Cluster API

  Alternatively, you may stop the cluster by setting the `spec.componentSpecs.stop` field to `true`  in the cluster configuration:

  ```bash
  kubectl patch cluster pg-cluster -n demo --type='json' -p='[
    {
      "op": "add",
      "path": "/spec/componentSpecs/0/stop",
      "value": true
    }
  ]'
  ```

  </TabItem>

</Tabs>

### Verifying Cluster Stop
Monitor the cluster's status to ensure it transitions to the Stopped state:
```bash
$ kubectl get cluster -n demo -w
```
Sample
```bash
NAME         CLUSTER-DEFINITION   TERMINATION-POLICY   STATUS     AGE
pg-cluster   postgresql           Delete               Stopping   6m3s
pg-cluster   postgresql           Delete               Stopped    6m55s
```

There is no Pods running in the cluster, but the persistent storage is retained.
```bash
$ kubectl get pods -n demo
```
Example Output:
```bash
No resources found in demo namespace.
```

```bash
$ kubectl get pvc -n demo
```
```bash
NAME                           STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS               VOLUMEATTRIBUTESCLASS   AGE
data-pg-cluster-postgresql-0   Bound    pvc-dcfb1ebc-2773-4edd-9898-e11da76062c4   20Gi       RWO            <STORAGE_CLASS_NAME>       <unset>                 19m
data-pg-cluster-postgresql-1   Bound    pvc-36366e01-0178-43fa-b1a0-4168b057dd10   20Gi       RWO            <STORAGE_CLASS_NAME>       <unset>                 19m
```

### Start the Cluster

Starting the cluster recreates the pods and brings the cluster back online.
<Tabs>

  <TabItem value="opsRequest" label="Use the OpsRequest API" default>

#### Option 1: Using OpsRequest

You can start the stopped cluster using an OpsRequest:

```yaml
apiVersion: operations.kubeblocks.io/v1alpha1
kind: OpsRequest
metadata:
  name: pg-cluster-start-ops
  namespace: demo
spec:
  # Specifies the name of the Cluster resource that this operation is targeting.
  clusterName: pg-cluster
  type: Start
```

  </TabItem>

  <TabItem value="ClusterAPI" label="Use the Cluster API">

#### Option 2: Using the Declarative Cluster API

Alternatively, you can start the cluster by:
- Setting the `spec.componentSpecs.stop` field to false, or
- Removing the `spec.componentSpecs.stop` field entirely.

```bash
kubectl patch cluster pg-cluster -n demo --type='json' -p='[
  {
    "op": "remove",
    "path": "/spec/componentSpecs/0/stop"
  }
]'
```
  </TabItem>

</Tabs>

### Verifying Cluster Start

Monitor the cluster's status to ensure it transitions back to the Running state:

```bash
$ kubectl get cluster -n demo -w
```

Example Output:
```bash
NAME         CLUSTER-DEFINITION   TERMINATION-POLICY   STATUS     AGE
pg-cluster   postgresql           Delete               Updating   22m
pg-cluster   postgresql           Delete               Running    22m
```

### Restart the Cluster

Restarting the cluster allows you to recreate the pods for specific components without deleting or stopping the entire cluster.

#### Using OpsRequest

To restart a specific component (e.g., postgresql), use the following OpsRequest:

```yaml
apiVersion: operations.kubeblocks.io/v1alpha1
kind: OpsRequest
metadata:
  name: pg-cluster-restart-ops
  namespace: demo
spec:
  clusterName: pg-cluster
  type: Restart
  restart:
  - componentName: postgresql
```

#### Verifying Cluster Restart

Monitor the cluster's status to ensure the restart is completed successfully:
```bash
kubectl get opsrequest pg-cluster-restart-ops -n demo -w
```
Example Output:
```bash
NAME                     TYPE      CLUSTER      STATUS    PROGRESS   AGE
pg-cluster-restart-ops   Restart   pg-cluster   Running   0/2        10s
pg-cluster-restart-ops   Restart   pg-cluster   Running   1/2        65s
pg-cluster-restart-ops   Restart   pg-cluster   Running   2/2        2m5s
pg-cluster-restart-ops   Restart   pg-cluster   Running   2/2        2m5s
pg-cluster-restart-ops   Restart   pg-cluster   Succeed   2/2        2m5s
```
Once the operation is complete, the cluster will return to the Running state.

## Summary
In this guide, you learned how to:
1. Stop a PostgreSQL cluster to suspend operations while retaining persistent storage.
2. Start a stopped cluster to bring it back online.
3. Restart specific cluster components to recreate their Pods without stopping the entire cluster.
By managing the lifecycle of your PostgreSQL cluster, you can optimize resource utilization, reduce costs, and maintain flexibility in your Kubernetes environment. KubeBlocks provides a seamless way to perform these operations, ensuring high availability and minimal disruption.